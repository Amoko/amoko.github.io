<!DOCTYPE html>
<html lang="en-US">

<head>

    <meta charset="UTF-8">
    <link rel="icon" type="image/png"  href="/img/favicon.jinja.png">
<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Logistic Regression | Yonji’s Blog</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Logistic Regression" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Logistic Regression Updated in March 06, 2019 逻辑回归（LR）是机器学习中的经典分类方法。 简单理解就是在线性回归+sigmoid激活函数，从而把分类问题转变为回归问题。 1 Logistic 回归模型 首先介绍Logistic 函数，由比利时人 Pierre Verhulst 于1845年研究模仿人口增长的曲线时发现并命名。其数学形式如下： 机器学习中常用的激活函数 sigmoid 函数（Sigmoid 意为S型），一般特指 logistic 函数的简化形式。其数学形式及函数曲线如下，值域为 $(0, 1)$。 进入正题，Logistic 回归模型的数学形式如下： Logistic 回归的输出是一个概率值，根据此概率值与阈值 $μ$ 的大小进行分类，$μ$ 一般取值0.5。 若 $p(y=1|x,\theta)&gt;μ$，则 $y^*=1$。函数具有对称性质，$p(y=0|x,\theta)=1-p(y=1|x,\theta)$。 因为线性回归残差服从高斯分布，所以可以使用最小二乘法进行参数求解；而 Logistic 回归的因变量、残差均为二项分布，不满足正态性，所以使用MLE为目标函数来进行参数$\theta$的求解。 2 最大似然估计（MLE） 最大似然估计Maximum Likelihood Estimation，是一个用来估计概率模型参数的方法，由英国人 Ronald Fisher 于上世纪20年代推广。MLE的两个条件是已知数据和概率分布假设（似然函数），其思想是求得这个分布具有什么样的参数值才能使我们观测到这组数据的可能性最大。 假设有一组独立同分布(i.i.d.)的随机变量 $X={x_1,x_2,\cdots,x_n}$，给定一个概率分布 $D$，假设其概率密度函数为 $f$，那么通过参数为 $\theta$ 的模型 $f$ 产生上面这组样本的概率为: MLE寻找使得这组样本出现的概率最大的参数 $\theta​$。也就是根据样本估计参数$\theta​$，定义似然函数为： 取对数后，对数似然函数如下： 最大似然估计即最大化对数似然函数 $l(\theta)$，$\theta^*=\mathop{\arg \max}_\theta l(\theta)$。 3 损失函数 那么具体到 Logistic 回归，样本标签 $y_i$ 取值为0或1，预测概率值为 $h_{\theta}(x)=\cfrac{1}{1+e^{-\theta^Tx}}$。 则似然函数为如下形式： 取对数后，对数似然函数为： 在不引入正则项的情况下，Logistic 回归的目标函数是最小化负的平均对数似然函数，如下： 由于多元变量很难求得解析解 $\theta^=\mathop{\arg \min}_\theta J(\theta)$，一般使用梯度下降法逼近 $\theta^$ 的最优值。 4 梯度下降法 梯度下降法 Gradient Descent 是最优化算法的一种，据说由法国人 Augustin Cauchy 于1847年提出。从函数当前点对应梯度的反方向按一定的步长$\alpha$进行迭代搜索，寻找函数$J(\theta)$的一个局部极小值点。若目标函数为凸函数，则得到的一定是全局最小值点。 GD 算法如下： 1）随机指定初始值 $\theta^k​$，$k=0​$ 2) 以全部数据为样本计算当前点 $\theta^k$ 的梯度，即对每个 $\theta_i$ 求偏导 3) 更新$\theta$值，迭代公式如下 4) 若函数 $J(\theta)$ 未收敛到极小值点，则令 $k=k+1$，重复步骤2、3；若已收敛，则停止迭代。 5 调包淆 from sklearn import linear_model, datasets from sklearn.model_selection import train_test_split def LR_demo(): # load datasets iris = datasets.load_iris() X = iris.data[:, :2] # use the first two features Y = iris.target X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.3, random_state=0) # fit model lr_model = linear_model.LogisticRegression(C=1e3) lr_model.fit(X_train, Y_train) # predict acc = lr_model.score(X_train,Y_train) prepro = lr_model.predict_proba(X_train) print acc, prepro Reference [1] 李航 (2012) 统计学习方法. 清华大学出版社, 北京. [2] 美团点评技术团队 logistic regression [3] Wikipedia Logistic function [4] Wikipedia 最尤推定 [5] 最大似然估计与贝叶斯估计 [6] 梯度下降算法 理论基础 [7] 梯度下降算法 python实现 [8] scikit-learn Logistic Regression" />
<meta property="og:description" content="Logistic Regression Updated in March 06, 2019 逻辑回归（LR）是机器学习中的经典分类方法。 简单理解就是在线性回归+sigmoid激活函数，从而把分类问题转变为回归问题。 1 Logistic 回归模型 首先介绍Logistic 函数，由比利时人 Pierre Verhulst 于1845年研究模仿人口增长的曲线时发现并命名。其数学形式如下： 机器学习中常用的激活函数 sigmoid 函数（Sigmoid 意为S型），一般特指 logistic 函数的简化形式。其数学形式及函数曲线如下，值域为 $(0, 1)$。 进入正题，Logistic 回归模型的数学形式如下： Logistic 回归的输出是一个概率值，根据此概率值与阈值 $μ$ 的大小进行分类，$μ$ 一般取值0.5。 若 $p(y=1|x,\theta)&gt;μ$，则 $y^*=1$。函数具有对称性质，$p(y=0|x,\theta)=1-p(y=1|x,\theta)$。 因为线性回归残差服从高斯分布，所以可以使用最小二乘法进行参数求解；而 Logistic 回归的因变量、残差均为二项分布，不满足正态性，所以使用MLE为目标函数来进行参数$\theta$的求解。 2 最大似然估计（MLE） 最大似然估计Maximum Likelihood Estimation，是一个用来估计概率模型参数的方法，由英国人 Ronald Fisher 于上世纪20年代推广。MLE的两个条件是已知数据和概率分布假设（似然函数），其思想是求得这个分布具有什么样的参数值才能使我们观测到这组数据的可能性最大。 假设有一组独立同分布(i.i.d.)的随机变量 $X={x_1,x_2,\cdots,x_n}$，给定一个概率分布 $D$，假设其概率密度函数为 $f$，那么通过参数为 $\theta$ 的模型 $f$ 产生上面这组样本的概率为: MLE寻找使得这组样本出现的概率最大的参数 $\theta​$。也就是根据样本估计参数$\theta​$，定义似然函数为： 取对数后，对数似然函数如下： 最大似然估计即最大化对数似然函数 $l(\theta)$，$\theta^*=\mathop{\arg \max}_\theta l(\theta)$。 3 损失函数 那么具体到 Logistic 回归，样本标签 $y_i$ 取值为0或1，预测概率值为 $h_{\theta}(x)=\cfrac{1}{1+e^{-\theta^Tx}}$。 则似然函数为如下形式： 取对数后，对数似然函数为： 在不引入正则项的情况下，Logistic 回归的目标函数是最小化负的平均对数似然函数，如下： 由于多元变量很难求得解析解 $\theta^=\mathop{\arg \min}_\theta J(\theta)$，一般使用梯度下降法逼近 $\theta^$ 的最优值。 4 梯度下降法 梯度下降法 Gradient Descent 是最优化算法的一种，据说由法国人 Augustin Cauchy 于1847年提出。从函数当前点对应梯度的反方向按一定的步长$\alpha$进行迭代搜索，寻找函数$J(\theta)$的一个局部极小值点。若目标函数为凸函数，则得到的一定是全局最小值点。 GD 算法如下： 1）随机指定初始值 $\theta^k​$，$k=0​$ 2) 以全部数据为样本计算当前点 $\theta^k$ 的梯度，即对每个 $\theta_i$ 求偏导 3) 更新$\theta$值，迭代公式如下 4) 若函数 $J(\theta)$ 未收敛到极小值点，则令 $k=k+1$，重复步骤2、3；若已收敛，则停止迭代。 5 调包淆 from sklearn import linear_model, datasets from sklearn.model_selection import train_test_split def LR_demo(): # load datasets iris = datasets.load_iris() X = iris.data[:, :2] # use the first two features Y = iris.target X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.3, random_state=0) # fit model lr_model = linear_model.LogisticRegression(C=1e3) lr_model.fit(X_train, Y_train) # predict acc = lr_model.score(X_train,Y_train) prepro = lr_model.predict_proba(X_train) print acc, prepro Reference [1] 李航 (2012) 统计学习方法. 清华大学出版社, 北京. [2] 美团点评技术团队 logistic regression [3] Wikipedia Logistic function [4] Wikipedia 最尤推定 [5] 最大似然估计与贝叶斯估计 [6] 梯度下降算法 理论基础 [7] 梯度下降算法 python实现 [8] scikit-learn Logistic Regression" />
<link rel="canonical" href="http://localhost:4000/2018/03/28/Logistic-Regression.html" />
<meta property="og:url" content="http://localhost:4000/2018/03/28/Logistic-Regression.html" />
<meta property="og:site_name" content="Yonji’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-03-28T00:00:00-07:00" />
<script type="application/ld+json">
{"description":"Logistic Regression Updated in March 06, 2019 逻辑回归（LR）是机器学习中的经典分类方法。 简单理解就是在线性回归+sigmoid激活函数，从而把分类问题转变为回归问题。 1 Logistic 回归模型 首先介绍Logistic 函数，由比利时人 Pierre Verhulst 于1845年研究模仿人口增长的曲线时发现并命名。其数学形式如下： 机器学习中常用的激活函数 sigmoid 函数（Sigmoid 意为S型），一般特指 logistic 函数的简化形式。其数学形式及函数曲线如下，值域为 $(0, 1)$。 进入正题，Logistic 回归模型的数学形式如下： Logistic 回归的输出是一个概率值，根据此概率值与阈值 $μ$ 的大小进行分类，$μ$ 一般取值0.5。 若 $p(y=1|x,\\theta)&gt;μ$，则 $y^*=1$。函数具有对称性质，$p(y=0|x,\\theta)=1-p(y=1|x,\\theta)$。 因为线性回归残差服从高斯分布，所以可以使用最小二乘法进行参数求解；而 Logistic 回归的因变量、残差均为二项分布，不满足正态性，所以使用MLE为目标函数来进行参数$\\theta$的求解。 2 最大似然估计（MLE） 最大似然估计Maximum Likelihood Estimation，是一个用来估计概率模型参数的方法，由英国人 Ronald Fisher 于上世纪20年代推广。MLE的两个条件是已知数据和概率分布假设（似然函数），其思想是求得这个分布具有什么样的参数值才能使我们观测到这组数据的可能性最大。 假设有一组独立同分布(i.i.d.)的随机变量 $X={x_1,x_2,\\cdots,x_n}$，给定一个概率分布 $D$，假设其概率密度函数为 $f$，那么通过参数为 $\\theta$ 的模型 $f$ 产生上面这组样本的概率为: MLE寻找使得这组样本出现的概率最大的参数 $\\theta​$。也就是根据样本估计参数$\\theta​$，定义似然函数为： 取对数后，对数似然函数如下： 最大似然估计即最大化对数似然函数 $l(\\theta)$，$\\theta^*=\\mathop{\\arg \\max}_\\theta l(\\theta)$。 3 损失函数 那么具体到 Logistic 回归，样本标签 $y_i$ 取值为0或1，预测概率值为 $h_{\\theta}(x)=\\cfrac{1}{1+e^{-\\theta^Tx}}$。 则似然函数为如下形式： 取对数后，对数似然函数为： 在不引入正则项的情况下，Logistic 回归的目标函数是最小化负的平均对数似然函数，如下： 由于多元变量很难求得解析解 $\\theta^=\\mathop{\\arg \\min}_\\theta J(\\theta)$，一般使用梯度下降法逼近 $\\theta^$ 的最优值。 4 梯度下降法 梯度下降法 Gradient Descent 是最优化算法的一种，据说由法国人 Augustin Cauchy 于1847年提出。从函数当前点对应梯度的反方向按一定的步长$\\alpha$进行迭代搜索，寻找函数$J(\\theta)$的一个局部极小值点。若目标函数为凸函数，则得到的一定是全局最小值点。 GD 算法如下： 1）随机指定初始值 $\\theta^k​$，$k=0​$ 2) 以全部数据为样本计算当前点 $\\theta^k$ 的梯度，即对每个 $\\theta_i$ 求偏导 3) 更新$\\theta$值，迭代公式如下 4) 若函数 $J(\\theta)$ 未收敛到极小值点，则令 $k=k+1$，重复步骤2、3；若已收敛，则停止迭代。 5 调包淆 from sklearn import linear_model, datasets from sklearn.model_selection import train_test_split def LR_demo(): # load datasets iris = datasets.load_iris() X = iris.data[:, :2] # use the first two features Y = iris.target X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.3, random_state=0) # fit model lr_model = linear_model.LogisticRegression(C=1e3) lr_model.fit(X_train, Y_train) # predict acc = lr_model.score(X_train,Y_train) prepro = lr_model.predict_proba(X_train) print acc, prepro Reference [1] 李航 (2012) 统计学习方法. 清华大学出版社, 北京. [2] 美团点评技术团队 logistic regression [3] Wikipedia Logistic function [4] Wikipedia 最尤推定 [5] 最大似然估计与贝叶斯估计 [6] 梯度下降算法 理论基础 [7] 梯度下降算法 python实现 [8] scikit-learn Logistic Regression","@type":"BlogPosting","url":"http://localhost:4000/2018/03/28/Logistic-Regression.html","headline":"Logistic Regression","dateModified":"2018-03-28T00:00:00-07:00","datePublished":"2018-03-28T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2018/03/28/Logistic-Regression.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="/assets/css/style.css?v=b0ca346b5b38b55e1001eb0920382c9d2e5aa454">

  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
        inlineMath: [['$','$']]
      }
    });
  </script>
</head>


  <body>
    <section class="page-header">
      <h1 class="project-name">Yonji's Blog|
      <a href="http://localhost:4000">Home</a></h1>
      <!--
      <h2 class="project-tagline">OMG! They killed Kenny!</h2>
      -->
      <a href="https://github.com/Amoko/amoko.github.io" class="btn">View on GitHub</a>
    
      
    </section>

    <section class="main-content">
      <h1 id="logistic-regression">Logistic Regression</h1>

<blockquote>
  <p>Updated in March 06, 2019</p>
</blockquote>

<p>逻辑回归（LR）是机器学习中的经典分类方法。</p>

<p>简单理解就是在线性回归+sigmoid激活函数，从而把分类问题转变为回归问题。</p>

<h2 id="1-logistic-回归模型">1 Logistic 回归模型</h2>

<p>首先介绍Logistic 函数，由<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/92/Flag_of_Belgium_%28civil%29.svg/38px-Flag_of_Belgium_%28civil%29.svg.png" alt="Belgium" />比利时人 Pierre Verhulst 于1845年研究模仿人口增长的曲线时发现并命名。其数学形式如下：</p>

<script type="math/tex; mode=display">y=\frac{L}{1+e^{-k(x-x_0)}}</script>

<p>机器学习中常用的激活函数 sigmoid 函数（Sigmoid 意为S型），一般特指 logistic 函数的简化形式。其数学形式及函数曲线如下，值域为 $(0, 1)$。</p>

<script type="math/tex; mode=display">y=\frac{1}{1+e^{-x}}\tag{1}</script>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/88/Logistic-curve.svg/480px-Logistic-curve.svg.png" alt="sigmod函数曲线" /></p>

<p>进入正题，Logistic 回归模型的数学形式如下：</p>

<script type="math/tex; mode=display">p(y=1|x,\theta)=\frac{1}{1+e^{-\theta^Tx}}\tag{2}</script>

<p>Logistic 回归的输出是一个概率值，根据此概率值与阈值 $μ$ 的大小进行分类，$μ$ 一般取值0.5。</p>

<p>
若 $p(y=1|x,\theta)&gt;μ$，则 $y^*=1$。函数具有对称性质，$p(y=0|x,\theta)=1-p(y=1|x,\theta)$。
</p>

<p>因为线性回归残差服从高斯分布，所以可以使用最小二乘法进行参数求解；而 Logistic 回归的因变量、残差均为二项分布，不满足正态性，所以使用MLE为目标函数来进行参数$\theta$的求解。</p>

<h2 id="2-最大似然估计mle">2 最大似然估计（MLE）</h2>

<p>最大似然估计Maximum Likelihood Estimation，是一个用来估计概率模型参数的方法，由<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/ae/Flag_of_the_United_Kingdom.svg/38px-Flag_of_the_United_Kingdom.svg.png" alt="Britain" />英国人 Ronald Fisher 于上世纪20年代推广。MLE的两个条件是已知数据和概率分布假设（似然函数），其思想是求得这个分布具有什么样的参数值才能使我们观测到这组数据的可能性最大。</p>

<p>假设有一组独立同分布(i.i.d.)的随机变量 $X={x_1,x_2,\cdots,x_n}$，给定一个概率分布 $D$，假设其概率密度函数为 $f$，那么通过参数为 $\theta$ 的模型 $f$ 产生上面这组样本的概率为:</p>

<script type="math/tex; mode=display">f(x_1,x_2,\cdots,x_n|\theta)=\prod_{i=1}^n f(x_i|\theta)</script>

<p>MLE寻找使得这组样本出现的概率最大的参数 $\theta​$。也就是根据样本估计参数$\theta​$，定义<strong>似然函数</strong>为：</p>

<script type="math/tex; mode=display">L(\theta|x_1,x_2,\cdots,x_n)=f(x_1,x_2,\cdots,x_n|\theta)=\prod_{i=1}^n f(x_i|\theta)</script>

<p>取对数后，<strong>对数似然函数</strong>如下：</p>

<script type="math/tex; mode=display">l(\theta)=\sum_{i=1}^n \ln f(x_i|\theta)\tag{3}</script>

<p>最大似然估计即最大化对数似然函数 $l(\theta)$，$\theta^*=\mathop{\arg \max}_\theta l(\theta)$。</p>

<h2 id="3-损失函数">3 损失函数</h2>

<p>那么具体到 Logistic 回归，样本标签 $y_i$ 取值为0或1，预测概率值为 $h_{\theta}(x)=\cfrac{1}{1+e^{-\theta^Tx}}$。</p>

<p>则似然函数为如下形式：</p>

<script type="math/tex; mode=display">L(\theta|x_1,x_2,\cdots,x_n)=\prod_{i=1}^n h(x_i)^{y_i}(1-h(x_i))^{1-y_i}</script>

<p>取对数后，<strong>对数似然函数</strong>为：</p>

<script type="math/tex; mode=display">l(\theta)= \sum_{i=1}^n [y_i\ln h(x_i)+(1-y_i)\ln (1-h(x_i))]\tag{4}</script>

<p>在不引入正则项的情况下，Logistic 回归的<strong>目标函数</strong>是最小化负的平均对数似然函数，如下：</p>

<script type="math/tex; mode=display">J(\theta)=-\frac{1}{n}l(\theta)</script>

<p>由于多元变量很难求得解析解 $\theta^<em>=\mathop{\arg \min}_\theta J(\theta)$，一般使用梯度下降法逼近 $\theta^</em>$ 的最优值。</p>

<h2 id="4-梯度下降法">4 梯度下降法</h2>

<p>梯度下降法 Gradient Descent 是最优化算法的一种，据说由<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Flag_of_France.svg/38px-Flag_of_France.svg.png" alt="France" />法国人 Augustin Cauchy 于1847年提出。从函数当前点对应梯度的反方向按一定的步长$\alpha$进行迭代搜索，寻找函数$J(\theta)$的一个局部极小值点。若目标函数为凸函数，则得到的一定是全局最小值点。</p>

<p>GD 算法如下：</p>

<p>1）随机指定初始值 $\theta^k​$，$k=0​$</p>

<p>2) 以全部数据为样本计算当前点 $\theta^k$ 的梯度，即对每个 $\theta_i$ 求偏导</p>

<script type="math/tex; mode=display">g^k_i=\frac{\partial J(\theta)}{\partial\theta_i}\tag{5}</script>

<p>3) 更新$\theta$值，迭代公式如下</p>

<script type="math/tex; mode=display">\theta^{k+1}_i=\theta^k_i-\alpha g^k_i\tag{6}</script>

<p>4) 若函数 $J(\theta)$ 未收敛到极小值点，则令 $k=k+1$，重复步骤2、3；若已收敛，则停止迭代。</p>

<h2 id="5-调包淆">5 调包淆</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">linear_model</span><span class="p">,</span> <span class="n">datasets</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>

<span class="k">def</span> <span class="nf">LR_demo</span><span class="p">():</span>
    <span class="c"># load datasets</span>
    <span class="n">iris</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">load_iris</span><span class="p">()</span>
	<span class="n">X</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>  <span class="c"># use the first two features</span>
	<span class="n">Y</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span>
    <span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">Y_train</span><span class="p">,</span> <span class="n">Y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="c"># fit model</span>
	<span class="n">lr_model</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">LogisticRegression</span><span class="p">(</span><span class="n">C</span><span class="o">=</span><span class="mf">1e3</span><span class="p">)</span>
	<span class="n">lr_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">Y_train</span><span class="p">)</span>
    
    <span class="c"># predict</span>
	<span class="n">acc</span> <span class="o">=</span> <span class="n">lr_model</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span><span class="n">Y_train</span><span class="p">)</span>
	<span class="n">prepro</span> <span class="o">=</span> <span class="n">lr_model</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">acc</span><span class="p">,</span> <span class="n">prepro</span>
</code></pre></div></div>

<h2 id="reference">Reference</h2>

<p>[1] 李航 (2012) 统计学习方法. 清华大学出版社, 北京.</p>

<p>[2] <a href="https://tech.meituan.com/intro_to_logistic_regression.html">美团点评技术团队 logistic regression</a></p>

<p>[3] <a href="https://en.wikipedia.org/wiki/Logistic_function">Wikipedia Logistic function</a></p>

<p>[4] <a href="https://ja.wikipedia.org/wiki/%E6%9C%80%E5%B0%A4%E6%8E%A8%E5%AE%9A">Wikipedia 最尤推定</a></p>

<p>[5] <a href="https://blog.csdn.net/bitcarmanlee/article/details/52201858">最大似然估计与贝叶斯估计</a></p>

<p>[6] <a href="http://www.hanlongfei.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/2015/07/29/gradient/">梯度下降算法 理论基础</a></p>

<p>[7] <a href="https://ctmakro.github.io/site/on_learning/gd.html">梯度下降算法 python实现</a></p>

<p>[8] <a href="http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html">scikit-learn Logistic Regression</a></p>



      <footer class="site-footer">
        
          <span class="site-footer-owner"><a href="https://github.com/Amoko/amoko.github.io">amoko.github.io</a> is maintained by <a href="https://github.com/Amoko">Amoko</a>.</span>
        
        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</span>
      </footer>
    </section>

    
  </body>
</html>
