<!DOCTYPE html>
<html lang="en-US">

<head>

    <meta charset="UTF-8">
    <link rel="icon" type="image/png"  href="/img/favicon.jinja.png">
<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Otsu の method | Yonji’s Blog</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Otsu の method" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Otsu の method 大津（Otsu）算法是图像领域一个基础的二值化方法，由日本人 大津展之おおつのぶゆき 于1979年提出。 大津算法的输入为灰度图，在灰度图上求得一个自适应阈值，以此阈值为界将灰度图像二值化。 1 灰度图 &amp; 二值图 对于灰度图，一个像素的存储空间为 8 bit，即取值空间为256，从黑到白共有256种亮度变化（0~255）。 对于二值图，一个像素的存储空间为 1 bit，即取值空间为2，只有黑、白两种取值。 下图为灰度图、二值图对比： 所以将灰度图二值化，也就是在灰色地带选一个阈值，将低于此值的归入黑色类，将高于此值的归入白色类。 Id est, from quantity to quality. 那么，这个阈值要怎么取才能更加公允呢？ 2 大津算法 算法步骤很简单，遍历所有灰度值，找到使类间方差最大的灰度值作为二值化的阈值，完了。 现在问题只有一个，类间方差是什么？ 大津算法所使用的类间方差定义，与Fisher线性判别（LDA）相同。 类间方差 阈值为 $t$ 时，类间方差 $\delta_t$ 定义如下： $p_i$，灰度值 $i$ 占比；$\mu=\sum_0^{255} ip_i$，全图灰度均值。 $w_0=\sum_0^{t}p_i$，黑色像素占比；$\mu_0=\cfrac{\sum_0^tip_i}{w_0}$，黑色像素灰度均值。 $w_1=\sum_{t+1}^{255}p_i$，白色像素占比；$\mu_1=\cfrac{\sum_{t+1}^{255}ip_i}{w_1}$，白色像素灰度均值。 大津法类间方差的计算，基于每个灰度值的占比。 因此计算灰度直方图后，对灰度直方图进行查表统计，就可以得到每个阈值下的类间方差。 3 NumPy实现 笔者基于 NumPy 对大津法的一个简单实现： import numpy as np import cv2 as cv import matplotlib.pyplot as plt def get_otsu_value(grayImg): # get hist ravel = grayImg.ravel() hist, _ = np.histogram(ravel, range(0,257)) sum_value = hist.sum() hist_p = [e/sum_value for e in hist] weight_p = [] for i in range(256): weight_p.append(i*hist_p[i]) hist_p = np.array(hist_p) weight_p = np.array(weight_p) # search the_max = [0, 0] mu = weight_p.sum() print(&quot;weighted mean:&quot;, mu) for i in range(0, 255): w0 = hist_p[:i].sum() w1 = hist_p[i:].sum() if w0 == 0 or w1 == 0: continue mu0 = weight_p[:i].sum() / w0 mu1 = weight_p[i:].sum() / w1 delta = w0*(mu0-mu)**2 + w1*(mu1-mu)**2 #delta2 = w0*w1*(mu0-mu1)**2 #print(delta, delta2) if delta &gt; the_max[1]: the_max = [i, delta] print(&quot;adjust thres, loss:&quot;, the_max) return the_max[0] img = cv.imread(&quot;bear.jpg&quot;) grayImg = cv.cvtColor(img, cv.COLOR_BGR2GRAY) thres = get_otsu_value(grayImg) ret, thresImg = cv.threshold(grayImg, thres, 255, cv.THRESH_BINARY) 4 OpenCV中直接调用 在 OpenCV 中使用大津法进行二值化，只需在二值化函数中加入 THRESH_OTSU 参数即可。 可以查看 OpenCV 源代码，在二值化函数中加入 THRESH_OTSU 参数，实质为在二值化前调用大津算法求自适应阈值，替换参数原阈值后再进行二值化。 4.1 Python import cv2 as cv import matplotlib.pyplot as plt img = cv.imread(&quot;bear.jpg&quot;) grayImg = cv.cvtColor(img, cv.COLOR_BGR2GRAY) # threshold with otsu ret, thresImg = cv.threshold(grayImg, 0, 255, cv.THRESH_OTSU) print(ret) plt.imshow(thresImg, cmap=plt.cm.gray) plt.show() 4.2 C++ #include &lt;opencv2/opencv.hpp&gt; using namespace cv; int main() { Mat img; img = imread(&quot;bear.jpg&quot;); Mat grayImg; cvtColor(img, grayImg, CV_BGR2GRAY); Mat biImg; // threshold with otsu threshold(grayImg, biImg, 0, 255, THRESH_BINARY | THRESH_OTSU); imshow(&quot;biImg&quot;, biImg); waitKey(0); return 0; } tips 据笔者在工程中的体验，大津算法的时间瓶颈在于统计灰度直方图步骤，而非阈值的遍历搜索步骤。 Reference [1] Wikipedia Grayscale [2] Wikipedia 大津算法 [3] OpenCV thresholding turorial" />
<meta property="og:description" content="Otsu の method 大津（Otsu）算法是图像领域一个基础的二值化方法，由日本人 大津展之おおつのぶゆき 于1979年提出。 大津算法的输入为灰度图，在灰度图上求得一个自适应阈值，以此阈值为界将灰度图像二值化。 1 灰度图 &amp; 二值图 对于灰度图，一个像素的存储空间为 8 bit，即取值空间为256，从黑到白共有256种亮度变化（0~255）。 对于二值图，一个像素的存储空间为 1 bit，即取值空间为2，只有黑、白两种取值。 下图为灰度图、二值图对比： 所以将灰度图二值化，也就是在灰色地带选一个阈值，将低于此值的归入黑色类，将高于此值的归入白色类。 Id est, from quantity to quality. 那么，这个阈值要怎么取才能更加公允呢？ 2 大津算法 算法步骤很简单，遍历所有灰度值，找到使类间方差最大的灰度值作为二值化的阈值，完了。 现在问题只有一个，类间方差是什么？ 大津算法所使用的类间方差定义，与Fisher线性判别（LDA）相同。 类间方差 阈值为 $t$ 时，类间方差 $\delta_t$ 定义如下： $p_i$，灰度值 $i$ 占比；$\mu=\sum_0^{255} ip_i$，全图灰度均值。 $w_0=\sum_0^{t}p_i$，黑色像素占比；$\mu_0=\cfrac{\sum_0^tip_i}{w_0}$，黑色像素灰度均值。 $w_1=\sum_{t+1}^{255}p_i$，白色像素占比；$\mu_1=\cfrac{\sum_{t+1}^{255}ip_i}{w_1}$，白色像素灰度均值。 大津法类间方差的计算，基于每个灰度值的占比。 因此计算灰度直方图后，对灰度直方图进行查表统计，就可以得到每个阈值下的类间方差。 3 NumPy实现 笔者基于 NumPy 对大津法的一个简单实现： import numpy as np import cv2 as cv import matplotlib.pyplot as plt def get_otsu_value(grayImg): # get hist ravel = grayImg.ravel() hist, _ = np.histogram(ravel, range(0,257)) sum_value = hist.sum() hist_p = [e/sum_value for e in hist] weight_p = [] for i in range(256): weight_p.append(i*hist_p[i]) hist_p = np.array(hist_p) weight_p = np.array(weight_p) # search the_max = [0, 0] mu = weight_p.sum() print(&quot;weighted mean:&quot;, mu) for i in range(0, 255): w0 = hist_p[:i].sum() w1 = hist_p[i:].sum() if w0 == 0 or w1 == 0: continue mu0 = weight_p[:i].sum() / w0 mu1 = weight_p[i:].sum() / w1 delta = w0*(mu0-mu)**2 + w1*(mu1-mu)**2 #delta2 = w0*w1*(mu0-mu1)**2 #print(delta, delta2) if delta &gt; the_max[1]: the_max = [i, delta] print(&quot;adjust thres, loss:&quot;, the_max) return the_max[0] img = cv.imread(&quot;bear.jpg&quot;) grayImg = cv.cvtColor(img, cv.COLOR_BGR2GRAY) thres = get_otsu_value(grayImg) ret, thresImg = cv.threshold(grayImg, thres, 255, cv.THRESH_BINARY) 4 OpenCV中直接调用 在 OpenCV 中使用大津法进行二值化，只需在二值化函数中加入 THRESH_OTSU 参数即可。 可以查看 OpenCV 源代码，在二值化函数中加入 THRESH_OTSU 参数，实质为在二值化前调用大津算法求自适应阈值，替换参数原阈值后再进行二值化。 4.1 Python import cv2 as cv import matplotlib.pyplot as plt img = cv.imread(&quot;bear.jpg&quot;) grayImg = cv.cvtColor(img, cv.COLOR_BGR2GRAY) # threshold with otsu ret, thresImg = cv.threshold(grayImg, 0, 255, cv.THRESH_OTSU) print(ret) plt.imshow(thresImg, cmap=plt.cm.gray) plt.show() 4.2 C++ #include &lt;opencv2/opencv.hpp&gt; using namespace cv; int main() { Mat img; img = imread(&quot;bear.jpg&quot;); Mat grayImg; cvtColor(img, grayImg, CV_BGR2GRAY); Mat biImg; // threshold with otsu threshold(grayImg, biImg, 0, 255, THRESH_BINARY | THRESH_OTSU); imshow(&quot;biImg&quot;, biImg); waitKey(0); return 0; } tips 据笔者在工程中的体验，大津算法的时间瓶颈在于统计灰度直方图步骤，而非阈值的遍历搜索步骤。 Reference [1] Wikipedia Grayscale [2] Wikipedia 大津算法 [3] OpenCV thresholding turorial" />
<link rel="canonical" href="http://localhost:4000/2018/12/08/Otsu-threshold.html" />
<meta property="og:url" content="http://localhost:4000/2018/12/08/Otsu-threshold.html" />
<meta property="og:site_name" content="Yonji’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-12-08T00:00:00-08:00" />
<script type="application/ld+json">
{"description":"Otsu の method 大津（Otsu）算法是图像领域一个基础的二值化方法，由日本人 大津展之おおつのぶゆき 于1979年提出。 大津算法的输入为灰度图，在灰度图上求得一个自适应阈值，以此阈值为界将灰度图像二值化。 1 灰度图 &amp; 二值图 对于灰度图，一个像素的存储空间为 8 bit，即取值空间为256，从黑到白共有256种亮度变化（0~255）。 对于二值图，一个像素的存储空间为 1 bit，即取值空间为2，只有黑、白两种取值。 下图为灰度图、二值图对比： 所以将灰度图二值化，也就是在灰色地带选一个阈值，将低于此值的归入黑色类，将高于此值的归入白色类。 Id est, from quantity to quality. 那么，这个阈值要怎么取才能更加公允呢？ 2 大津算法 算法步骤很简单，遍历所有灰度值，找到使类间方差最大的灰度值作为二值化的阈值，完了。 现在问题只有一个，类间方差是什么？ 大津算法所使用的类间方差定义，与Fisher线性判别（LDA）相同。 类间方差 阈值为 $t$ 时，类间方差 $\\delta_t$ 定义如下： $p_i$，灰度值 $i$ 占比；$\\mu=\\sum_0^{255} ip_i$，全图灰度均值。 $w_0=\\sum_0^{t}p_i$，黑色像素占比；$\\mu_0=\\cfrac{\\sum_0^tip_i}{w_0}$，黑色像素灰度均值。 $w_1=\\sum_{t+1}^{255}p_i$，白色像素占比；$\\mu_1=\\cfrac{\\sum_{t+1}^{255}ip_i}{w_1}$，白色像素灰度均值。 大津法类间方差的计算，基于每个灰度值的占比。 因此计算灰度直方图后，对灰度直方图进行查表统计，就可以得到每个阈值下的类间方差。 3 NumPy实现 笔者基于 NumPy 对大津法的一个简单实现： import numpy as np import cv2 as cv import matplotlib.pyplot as plt def get_otsu_value(grayImg): # get hist ravel = grayImg.ravel() hist, _ = np.histogram(ravel, range(0,257)) sum_value = hist.sum() hist_p = [e/sum_value for e in hist] weight_p = [] for i in range(256): weight_p.append(i*hist_p[i]) hist_p = np.array(hist_p) weight_p = np.array(weight_p) # search the_max = [0, 0] mu = weight_p.sum() print(&quot;weighted mean:&quot;, mu) for i in range(0, 255): w0 = hist_p[:i].sum() w1 = hist_p[i:].sum() if w0 == 0 or w1 == 0: continue mu0 = weight_p[:i].sum() / w0 mu1 = weight_p[i:].sum() / w1 delta = w0*(mu0-mu)**2 + w1*(mu1-mu)**2 #delta2 = w0*w1*(mu0-mu1)**2 #print(delta, delta2) if delta &gt; the_max[1]: the_max = [i, delta] print(&quot;adjust thres, loss:&quot;, the_max) return the_max[0] img = cv.imread(&quot;bear.jpg&quot;) grayImg = cv.cvtColor(img, cv.COLOR_BGR2GRAY) thres = get_otsu_value(grayImg) ret, thresImg = cv.threshold(grayImg, thres, 255, cv.THRESH_BINARY) 4 OpenCV中直接调用 在 OpenCV 中使用大津法进行二值化，只需在二值化函数中加入 THRESH_OTSU 参数即可。 可以查看 OpenCV 源代码，在二值化函数中加入 THRESH_OTSU 参数，实质为在二值化前调用大津算法求自适应阈值，替换参数原阈值后再进行二值化。 4.1 Python import cv2 as cv import matplotlib.pyplot as plt img = cv.imread(&quot;bear.jpg&quot;) grayImg = cv.cvtColor(img, cv.COLOR_BGR2GRAY) # threshold with otsu ret, thresImg = cv.threshold(grayImg, 0, 255, cv.THRESH_OTSU) print(ret) plt.imshow(thresImg, cmap=plt.cm.gray) plt.show() 4.2 C++ #include &lt;opencv2/opencv.hpp&gt; using namespace cv; int main() { Mat img; img = imread(&quot;bear.jpg&quot;); Mat grayImg; cvtColor(img, grayImg, CV_BGR2GRAY); Mat biImg; // threshold with otsu threshold(grayImg, biImg, 0, 255, THRESH_BINARY | THRESH_OTSU); imshow(&quot;biImg&quot;, biImg); waitKey(0); return 0; } tips 据笔者在工程中的体验，大津算法的时间瓶颈在于统计灰度直方图步骤，而非阈值的遍历搜索步骤。 Reference [1] Wikipedia Grayscale [2] Wikipedia 大津算法 [3] OpenCV thresholding turorial","@type":"BlogPosting","url":"http://localhost:4000/2018/12/08/Otsu-threshold.html","headline":"Otsu の method","dateModified":"2018-12-08T00:00:00-08:00","datePublished":"2018-12-08T00:00:00-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2018/12/08/Otsu-threshold.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="/assets/css/style.css?v=b0ca346b5b38b55e1001eb0920382c9d2e5aa454">

  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
        inlineMath: [['$','$']]
      }
    });
  </script>
</head>


  <body>
    <section class="page-header">
      <h1 class="project-name">Yonji's Blog|
      <a href="http://localhost:4000">Home</a></h1>
      <!--
      <h2 class="project-tagline">OMG! They killed Kenny!</h2>
      -->
      <a href="https://github.com/Amoko/amoko.github.io" class="btn">View on GitHub</a>
    
      
    </section>

    <section class="main-content">
      <h1 id="otsu-の-method">Otsu の method</h1>

<p>大津（Otsu）算法是图像领域一个基础的二值化方法，由<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9e/Flag_of_Japan.svg/38px-Flag_of_Japan.svg.png" alt="" />日本人 <ruby>大津展之<rt>おおつのぶゆき</rt></ruby> 于1979年提出。</p>

<p>大津算法的输入为灰度图，在灰度图上求得一个自适应阈值，以此阈值为界将灰度图像二值化。</p>

<h2 id="1-灰度图--二值图">1 灰度图 &amp; 二值图</h2>

<p>对于灰度图，一个像素的存储空间为 8 bit，即取值空间为256，从黑到白共有256种亮度变化（0~255）。</p>

<p>对于二值图，一个像素的存储空间为 1 bit，即取值空间为2，只有黑、白两种取值。</p>

<p>下图为灰度图、二值图对比：</p>

<p><img src="/img/8bit_1bit.png" alt="" /></p>

<p>所以将灰度图二值化，也就是在灰色地带选一个阈值，将低于此值的归入黑色类，将高于此值的归入白色类。</p>

<p>Id est, from quantity to quality.</p>

<p>那么，这个阈值要怎么取才能更加公允呢？</p>

<h2 id="2-大津算法">2 大津算法</h2>

<p>算法步骤很简单，<strong>遍历所有灰度值，找到使类间方差最大的灰度值作为二值化的阈值</strong>，完了。</p>

<p>现在问题只有一个，类间方差是什么？</p>

<p>大津算法所使用的类间方差定义，与Fisher线性判别（LDA）相同。</p>

<p><strong>类间方差</strong></p>

<p>阈值为 $t$ 时，类间方差 $\delta_t$ 定义如下：
<script type="math/tex">% <![CDATA[
\begin{aligned}
\delta_t^2 &= w_0(\mu_0-\mu)^2 + w_1(\mu_1-\mu)^2 \\
&= w_0w_1(\mu_0-\mu_1)^2
\end{aligned}\tag{1} %]]></script>
$p_i$，灰度值 $i$ 占比；$\mu=\sum_0^{255} ip_i$，全图灰度均值。</p>

<p>$w_0=\sum_0^{t}p_i$，黑色像素占比；$\mu_0=\cfrac{\sum_0^tip_i}{w_0}$，黑色像素灰度均值。</p>

<p>$w_1=\sum_{t+1}^{255}p_i$，白色像素占比；$\mu_1=\cfrac{\sum_{t+1}^{255}ip_i}{w_1}$，白色像素灰度均值。</p>

<p>大津法类间方差的计算，基于每个灰度值的占比。</p>

<p>因此计算灰度直方图后，对灰度直方图进行查表统计，就可以得到每个阈值下的类间方差。</p>

<p><img src="/img/gray_histogram.png" alt="" /></p>

<h2 id="3-numpy实现">3 NumPy实现</h2>

<p>笔者基于 NumPy 对大津法的一个简单实现：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">cv2</span> <span class="k">as</span> <span class="n">cv</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="k">def</span> <span class="nf">get_otsu_value</span><span class="p">(</span><span class="n">grayImg</span><span class="p">):</span>
    <span class="c"># get hist</span>
    <span class="n">ravel</span> <span class="o">=</span> <span class="n">grayImg</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">hist</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">ravel</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">257</span><span class="p">))</span>
    <span class="n">sum_value</span> <span class="o">=</span> <span class="n">hist</span><span class="o">.</span><span class="nb">sum</span><span class="p">()</span>
    <span class="n">hist_p</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">/</span><span class="n">sum_value</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">hist</span><span class="p">]</span>
    <span class="n">weight_p</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">256</span><span class="p">):</span>
        <span class="n">weight_p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">hist_p</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">hist_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hist_p</span><span class="p">)</span>
    <span class="n">weight_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weight_p</span><span class="p">)</span>
    
    <span class="c"># search</span>
    <span class="n">the_max</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">weight_p</span><span class="o">.</span><span class="nb">sum</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"weighted mean:"</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">):</span>
        <span class="n">w0</span> <span class="o">=</span> <span class="n">hist_p</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="nb">sum</span><span class="p">()</span>
        <span class="n">w1</span> <span class="o">=</span> <span class="n">hist_p</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span><span class="o">.</span><span class="nb">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">w0</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">w1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">mu0</span> <span class="o">=</span> <span class="n">weight_p</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="nb">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">w0</span>
        <span class="n">mu1</span> <span class="o">=</span> <span class="n">weight_p</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span><span class="o">.</span><span class="nb">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">w1</span>
     
        <span class="n">delta</span> <span class="o">=</span> <span class="n">w0</span><span class="o">*</span><span class="p">(</span><span class="n">mu0</span><span class="o">-</span><span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">w1</span><span class="o">*</span><span class="p">(</span><span class="n">mu1</span><span class="o">-</span><span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="c">#delta2 = w0*w1*(mu0-mu1)**2</span>
        <span class="c">#print(delta, delta2)</span>
        <span class="k">if</span> <span class="n">delta</span> <span class="o">&gt;</span> <span class="n">the_max</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">the_max</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">delta</span><span class="p">]</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"adjust thres, loss:"</span><span class="p">,</span> <span class="n">the_max</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">the_max</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="n">img</span>  <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="s">"bear.jpg"</span><span class="p">)</span>
<span class="n">grayImg</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>
<span class="n">thres</span> <span class="o">=</span> <span class="n">get_otsu_value</span><span class="p">(</span><span class="n">grayImg</span><span class="p">)</span>
<span class="n">ret</span><span class="p">,</span> <span class="n">thresImg</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">threshold</span><span class="p">(</span><span class="n">grayImg</span><span class="p">,</span> <span class="n">thres</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">cv</span><span class="o">.</span><span class="n">THRESH_BINARY</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="4-opencv中直接调用">4 OpenCV中直接调用</h2>

<p>在 OpenCV 中使用大津法进行二值化，只需在二值化函数中加入 <code>THRESH_OTSU</code> 参数即可。</p>

<p>可以查看 OpenCV 源代码，在二值化函数中加入 <code>THRESH_OTSU</code> 参数，实质为在二值化前调用大津算法求自适应阈值，<strong>替换参数原阈值后</strong>再进行二值化。</p>

<h3 id="41-python">4.1 Python</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">cv2</span> <span class="k">as</span> <span class="n">cv</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="n">img</span>  <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="s">"bear.jpg"</span><span class="p">)</span>
<span class="n">grayImg</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cv</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>
<span class="c"># threshold with otsu</span>
<span class="n">ret</span><span class="p">,</span> <span class="n">thresImg</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">threshold</span><span class="p">(</span><span class="n">grayImg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">cv</span><span class="o">.</span><span class="n">THRESH_OTSU</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">thresImg</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="42-c">4.2 C++</h3>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;opencv2/opencv.hpp&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">cv</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Mat</span> <span class="n">img</span><span class="p">;</span>
	<span class="n">img</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="s">"bear.jpg"</span><span class="p">);</span>
	<span class="n">Mat</span> <span class="n">grayImg</span><span class="p">;</span>
	<span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">grayImg</span><span class="p">,</span> <span class="n">CV_BGR2GRAY</span><span class="p">);</span>
	<span class="n">Mat</span> <span class="n">biImg</span><span class="p">;</span>
	<span class="c1">// threshold with otsu
</span>	<span class="n">threshold</span><span class="p">(</span><span class="n">grayImg</span><span class="p">,</span> <span class="n">biImg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">THRESH_BINARY</span> <span class="o">|</span> <span class="n">THRESH_OTSU</span><span class="p">);</span>
	<span class="n">imshow</span><span class="p">(</span><span class="s">"biImg"</span><span class="p">,</span> <span class="n">biImg</span><span class="p">);</span>
	<span class="n">waitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>tips</strong></p>

<p>据笔者在工程中的体验，大津算法的时间瓶颈在于统计灰度直方图步骤，而非阈值的遍历搜索步骤。</p>

<h2 id="reference">Reference</h2>

<p>[1] <a href="https://en.wikipedia.org/wiki/Grayscale">Wikipedia Grayscale</a></p>

<p>[2] <a href="https://zh.wikipedia.org/wiki/%E5%A4%A7%E6%B4%A5%E7%AE%97%E6%B3%95">Wikipedia 大津算法</a></p>

<p>[3] <a href="https://docs.opencv.org/3.4/d7/d4d/tutorial_py_thresholding.html">OpenCV thresholding turorial</a></p>



      <footer class="site-footer">
        
          <span class="site-footer-owner"><a href="https://github.com/Amoko/amoko.github.io">amoko.github.io</a> is maintained by <a href="https://github.com/Amoko">Amoko</a>.</span>
        
        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</span>
      </footer>
    </section>

    
  </body>
</html>
